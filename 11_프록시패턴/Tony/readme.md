# 11. 프록시 패턴 - 객체 "접근 제어"하기

- 프록시는 자신이 대변하는 객체와 그 객체에 접근하려는 클라이언트 사이에서 여러 가지 방식으로 작업을 제어합니다.

#### 프록시 vs 게이트웨이

- https://swimjiy.github.io/2020-04-11-web-gateway
- https://velog.io/@hyun-jii/%ED%94%84%EB%A1%9D%EC%8B%9CProxy-vs-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4Gateway
- https://coding-start.tistory.com/342
- 게이트웨이
  - 중계 + 서로 다른 네트워크(또는 프로토콜) 간의 통신을 가능하게
  - (인천 국제)공항 느낌
- 프록시
  - 중계 + 필터
  - 캐시 프록시
  - 포워드 프록시
  - 리버스 프록시

#### 뽑기 기계의 상태 파악하기

- 모든 뽑기 기계의 재고와 현재 상태를 알려주는 기능을 추가
- 10장에서 뽑기 기계 코드에 알맹이의 개수를 알려주는 메소드(getCount())와 기계의 현재 상태를 알려주는 메소드 (getState())를 추가했었음
- CEO용 보고서를 추력하는 메소드만 만들면 될 것 같다
- 그리고 각 뽑기 기계의 위치를 알려주는 필드도 추가해야 한다
- 뽑기 기계의 위치를 알려주는 필드를 추가하면서 뽑기 기계의 상태를 알려주는 메소드도 추가해야 한다

## 모니터링 코드 만들기

- GumballMachine 클래스에 뽑기 기ㅖ의 현재 위치를 알려주는 기능을 추가해봅시다.

- 기계의 위치, 재고, 현재 상태를 가져와서 깔끔한 보고서를 출력해 주는 GumballMonitor 클래스를 만들어보자

## 모니터링 기능 테스트

## 모니터링 기능을 위한 프록시 만들기

- 원격 프록시
- GumballMonitor 클래스에 뽑기 기계 레퍼런스만 넘겨주면 거기서 보고서를 만들어 준다
- 문제는 이 코드가 뽑기 기계랑 같은 JVM에서 돌아가는데 CEO는 자기 사무실에 있는 컴퓨터로 멀리 떨어져 있는 뽑기 기계를 모니터링 하고 싶어한다
- GumballMonitor 클래스는 그대로 두고, 원격 객체의 프록시만 넘기면 되지 않을까?
- 프록신느 진짜 객체를 대신하는 역할을 맡는다
  - 뽑기 기계 객체 역할을 맡는다
- 그런데 실제로는 네트워크로 멀리 떨어져 있는 진짜 GumballMachine 클래스와 데이터를 주고 받는다
- 그리고 그 프록시는 진짜 객체 처럼 행동하지만, 실제로는 네트워크로 진짜 객체와 데이터를 주고 받는다
- 뽑기 기ㅖ가 일종의 서비스 역할을 맡고, 네트워크로 들어오는 요청을 수용할 수 있도록 하자
- GumballMonitor 클래스에 프록시 객체의 레퍼런스를 받아오는 기능도 추가하자

## 원격 프록시의 역할

- 원격 프록시는 원격 객체의 로컬 대변자 역할을 합니다

  - 원격 객체란?
    - 다른 자바 가상 머신의 힙에서 살고 있는 객체(다른 주소 공간에서 돌아가고 있는 객체)를 뜻합니다
  - 로컬 대변자란?
    - 로컬 대변자의 어떤 메소드를 호출하면, 다른 원격 객체에게 그 메소드 호출을 전달해 주는 객체의 로컬 대변자

- 클라이언트 객체는 원격 객체의 메소드 호출을 하는 것 처럼 행동합니다
  - 하지만 실제로는 로컬 힙에 들어있는 '프록시' 객체의 메소드를 호출하고 있죠
- 네트워크 통신과 관련된 저수준 작업은 이 프록시 객체에서 처리해 줍니다

## 모니터링 코드에 원격 프록시 추가하기

- RMI(Remote Method Invocation) : 원격 메소드 호출을 위한 자바 API

## 원격 메소드(RMI)의 기초

- 서버는 서비스 보조 객체(service helper)가 있어서, Socket 연결로 클라이언트 보조 객체로부터 요청을 받아오고,
- 호출 정보를 해석해서 진짜 서비스 객체에 있는 진짜 메소드를 호출합니다.
- 따라서 서비스 객체는 그 메소드 호출이 원격 클라이언트가 아닌 로컬 객체로 부터 들어온다고 생각하죠
- 서비스 보조 객체는 서비스로부터 리턴값을 받아서 Socket의 출력 스트림으로 클라이언트 보조객체에게 전송합니다
- 클라이언트 보조 객체는 그 정보를 해석해서 클라이언트 객체에 리턴합니다

## 메소드 호출 과정 알아보기

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%951.png)

1. 클라이언트 객체에서 클라이언트 보조 객체의 doBigThing()을 호출합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%952.png)

2. 클라이언트 보조 객체는 메소드 호출 정보(인자, 메소드 이름 등)를 잘 포장해서 네트워크로 서비스 보조 객체에게 전달합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%953.png)

3. 서비스 보조 객체는 클라이언트 보조 객체로부터 받은 정보를 해석해서 어떤 객체의 어떤 메소드를 호출할지 알아낸 다음 진짜 서비스 객체의 메소드를 호출합니다

- 서비스 객체에서 실제로 작업을 처리

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%954.png)

4. 서비스 객체의 메소드 실행이 끝나면 서비스 보조 객체에 어떤 결과가 리턴됩니다.

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%955.png)

5. 서비스 보조 객체는 호출 결과로 리턴된 정보를 포장해서 네트워크로 클라이언트 보조 객체에게 전달합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%956.png)

6. 클라이언트 보조 객체는 리턴된 정보를 해석해서 클라이언트 객체에게 리턴합니다.

- 클라이언트 객체는 메소드 호출이 어디로 전달되었는지, 어디에서 리턴되었는지 전혀 알 수 없습니다

## 자바 RMI 기초

- 생략

## 뽑기 기계용 원격 프록시 고민하기

## 원격 프록시와 가상 프록시 비교하기

- 원격 프록시 : 다른 jvm에 들어있는 객체의 대리인에 해당하는 로컬 객체
  - 프록시의 메소드를 호출하면 그 호출이 네트워크로 전달되어 결국 원격 객체의 메소드가 호출 됩니다
  - 그 결과는 다시 프록시를 거쳐서 클라이언트에게 전달됩니다
- 가상 프록시 : 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미루는 기능을 제공합니다

## 누가 무엇을 할까요?

- 데코레이터 : 다른 객체를 감싸서 새로운 행동을 추가해 줍니다
- 퍼사드 : 여러 객체를 감싸서 인터페이스를 단순하게 만듭니다
- 프록시 : 다른 객체를 감싸서 접근을 제어합니다
- 어댑터 : 다른 객체를 감싸서 다른 인터페이스를 제공합니다
- 공통점
  - 본체가 따로 있다

## 실전! 프록시 동물원 탐방하기

- 방화벽 프록시(Firewall Proxy)

  - 일련의 네트워크 자원으로의 접근을 제어함으로써 주제를 '나쁜' 클라이언트로부터 보호해 줍니다

- 스마트 레퍼런스 프록시(Smart Reference Proxy)

  - 주제가 참조될 때 마다 추가 행동을 제공합니다
  - 객체의 레퍼런스 개수를 센다든가 하는 식으로 말이죠

- 캐싱 프록시(Caching Proxy)

  - 비용이 많이 드는 작업의 결과를 임시로 저장해 줍니다
  - 여러 클라이언트에서 결과를 공유하게 해 줌으로써 계산 시간과 네트워크 지연을 줄여 주는 효과도 있습니다

- 동기화 프록시(Synchronization Proxy)

  - 여러 스레드에서 주제에 접근할 때 안전하게 작업을 처리할 수 있게 해줍니다

- 복잡도 숨김 프록시(Complexity Hiding Proxy)

  - 복잡한 클래스의 집합으로의 접근을 제어하고, 그 복잡도를 숨겨 줍니다
  - 퍼사드 프록시(Facade Proxy)라고도 합니다
  - 이 프록시와 퍼사드 패턴의 차이점은 프록시는 접근을 제어하지만 퍼사드 패턴은 대체 인터페이스만 제공한다는 점에 있습니다

- 지연 초기화 프록시(Lazy Initialization Proxy)
  - 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어합니다
  - 변형된 가상 프록시라고 할 수 있습니다

## 디자인 도구상자 안에 들어가야 할 도구들

### 객체 지향 원칙

- 바뀌는 부분은 캡슐화합니다
- 상속보다는 구성을 활용한다
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다
- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다
- 클래스는 확장에는 열려 있지만 변경에는 닫혀 있어야 한다
- 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다
- 진짜 절친에게만 이야기한다
- 먼저 연락하지 마세요. 저희가 연락드리겠습니다
- 어떤 클래스가 바뀌는 이유는 하나뿐이어야만 한다

### 객체 지향 기초

- 추상화
- 캡슐화
- 다형성
- 상속

### 객체 지향 패턴

- 프록시 패턴
  - 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공합니다

### 핵심 정리

- 프록시 패턴을 사용하면 어떤 객체의 대리인을 내세워서 클라이언트의 접근을 제어할 수 있습니다.
- 접근을 관리하는 방법에는 여러가지가 있습니다
- 원격 프록시는 클라이언트와 원격 객체 사이의 데이터 전달을 관리해 줍니다
- 가상 프록시는 인스턴스를 만드는 데 많은 비용이 드는 객체로의 접근을 제어합니다
- 보호 프록시는 호출하는 쪽의 권한에 따라서 객체에 있는 메소드로의 접근을 제어합니다
- 그 외에도 캐싱프록시, 동기화 프록시, 방화벽 프록시, 지연 복사 프록시와 같이 다양한 변형 된 프록시 패턴이 있습니다
- 프록시 패턴의 구조는 데코레이터 패턴의 구조와 비슷하지만 그 용도는 다릅니다
- 데코레이터 패턴은 객체에 행동을 추가하지만 프록시 패턴은 접근을 제어합니다
- 자바에 내장된 프록시 지원 기능을 사용하면 동적 프록시 클래스를 만들어서 원하는 핸들러에서 호출을 처리하도록 할 수 있습니다
- 다른 래퍼(Wrapper)를 쓸 때와 마찬가지로 프록시를 쓰면 디자인에 포함되는 클래스와 객체의 수가 늘어납니다
