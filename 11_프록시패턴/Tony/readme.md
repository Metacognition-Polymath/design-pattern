# 11. 프록시 패턴 - 객체 "접근 제어"하기

- 프록시는 자신이 대변하는 객체와 그 객체에 접근하려는 클라이언트 사이에서 여러 가지 방식으로 작업을 제어합니다.

#### 프록시 vs 게이트웨이

- https://swimjiy.github.io/2020-04-11-web-gateway
- https://velog.io/@hyun-jii/%ED%94%84%EB%A1%9D%EC%8B%9CProxy-vs-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4Gateway
- https://coding-start.tistory.com/342
- 게이트웨이
  - 중계 + 서로 다른 네트워크(또는 프로토콜) 간의 통신을 가능하게
  - (인천 국제)공항 느낌
- 프록시
  - 중계 + 필터
  - 캐시 프록시
  - 포워드 프록시
  - 리버스 프록시

#### 뽑기 기계의 상태 파악하기

- 모든 뽑기 기계의 재고와 현재 상태를 알려주는 기능을 추가
- 10장에서 뽑기 기계 코드에 알맹이의 개수를 알려주는 메소드(getCount())와 기계의 현재 상태를 알려주는 메소드 (getState())를 추가했었음
- CEO용 보고서를 추력하는 메소드만 만들면 될 것 같다
- 그리고 각 뽑기 기계의 위치를 알려주는 필드도 추가해야 한다
- 뽑기 기계의 위치를 알려주는 필드를 추가하면서 뽑기 기계의 상태를 알려주는 메소드도 추가해야 한다

## 모니터링 코드 만들기

- GumballMachine 클래스에 뽑기 기ㅖ의 현재 위치를 알려주는 기능을 추가해봅시다.

- 기계의 위치, 재고, 현재 상태를 가져와서 깔끔한 보고서를 출력해 주는 GumballMonitor 클래스를 만들어보자

## 모니터링 기능 테스트

## 모니터링 기능을 위한 프록시 만들기

- 원격 프록시
- GumballMonitor 클래스에 뽑기 기계 레퍼런스만 넘겨주면 거기서 보고서를 만들어 준다
- 문제는 이 코드가 뽑기 기계랑 같은 JVM에서 돌아가는데 CEO는 자기 사무실에 있는 컴퓨터로 멀리 떨어져 있는 뽑기 기계를 모니터링 하고 싶어한다
- GumballMonitor 클래스는 그대로 두고, 원격 객체의 프록시만 넘기면 되지 않을까?
- 프록신느 진짜 객체를 대신하는 역할을 맡는다
  - 뽑기 기계 객체 역할을 맡는다
- 그런데 실제로는 네트워크로 멀리 떨어져 있는 진짜 GumballMachine 클래스와 데이터를 주고 받는다
- 그리고 그 프록시는 진짜 객체 처럼 행동하지만, 실제로는 네트워크로 진짜 객체와 데이터를 주고 받는다
- 뽑기 기ㅖ가 일종의 서비스 역할을 맡고, 네트워크로 들어오는 요청을 수용할 수 있도록 하자
- GumballMonitor 클래스에 프록시 객체의 레퍼런스를 받아오는 기능도 추가하자

## 원격 프록시의 역할

- 원격 프록시는 원격 객체의 로컬 대변자 역할을 합니다

  - 원격 객체란?
    - 다른 자바 가상 머신의 힙에서 살고 있는 객체(다른 주소 공간에서 돌아가고 있는 객체)를 뜻합니다
  - 로컬 대변자란?
    - 로컬 대변자의 어떤 메소드를 호출하면, 다른 원격 객체에게 그 메소드 호출을 전달해 주는 객체의 로컬 대변자

- 클라이언트 객체는 원격 객체의 메소드 호출을 하는 것 처럼 행동합니다
  - 하지만 실제로는 로컬 힙에 들어있는 '프록시' 객체의 메소드를 호출하고 있죠
- 네트워크 통신과 관련된 저수준 작업은 이 프록시 객체에서 처리해 줍니다

## 모니터링 코드에 원격 프록시 추가하기

- RMI(Remote Method Invocation) : 원격 메소드 호출을 위한 자바 API

## 원격 메소드(RMI)의 기초

- 서버는 서비스 보조 객체(service helper)가 있어서, Socket 연결로 클라이언트 보조 객체로부터 요청을 받아오고,
- 호출 정보를 해석해서 진짜 서비스 객체에 있는 진짜 메소드를 호출합니다.
- 따라서 서비스 객체는 그 메소드 호출이 원격 클라이언트가 아닌 로컬 객체로 부터 들어온다고 생각하죠
- 서비스 보조 객체는 서비스로부터 리턴값을 받아서 Socket의 출력 스트림으로 클라이언트 보조객체에게 전송합니다
- 클라이언트 보조 객체는 그 정보를 해석해서 클라이언트 객체에 리턴합니다

## 메소드 호출 과정 알아보기

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%951.png)

1. 클라이언트 객체에서 클라이언트 보조 객체의 doBigThing()을 호출합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%952.png)

2. 클라이언트 보조 객체는 메소드 호출 정보(인자, 메소드 이름 등)를 잘 포장해서 네트워크로 서비스 보조 객체에게 전달합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%953.png)

3. 서비스 보조 객체는 클라이언트 보조 객체로부터 받은 정보를 해석해서 어떤 객체의 어떤 메소드를 호출할지 알아낸 다음 진짜 서비스 객체의 메소드를 호출합니다

- 서비스 객체에서 실제로 작업을 처리

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%954.png)

4. 서비스 객체의 메소드 실행이 끝나면 서비스 보조 객체에 어떤 결과가 리턴됩니다.

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%955.png)

5. 서비스 보조 객체는 호출 결과로 리턴된 정보를 포장해서 네트워크로 클라이언트 보조 객체에게 전달합니다

![](./images/%EB%A9%94%EC%86%8C%EB%93%9C%ED%98%B8%EC%B6%9C%EA%B3%BC%EC%A0%956.png)

6. 클라이언트 보조 객체는 리턴된 정보를 해석해서 클라이언트 객체에게 리턴합니다.

- 클라이언트 객체는 메소드 호출이 어디로 전달되었는지, 어디에서 리턴되었는지 전혀 알 수 없습니다
