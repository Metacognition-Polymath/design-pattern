# 6. 커맨드 패턴 - 호출 캡슐화 하기

- 캡슐화를 더 높은 수준으로 끌어올려보자
  - 메소드 호출을 캡슐화

## 만능 IOT 리모컨

## 협력 업체 클래스 살펴보기

- 각 기기마다 인터페이스가 다르다
- 만능 리모컨에 어떻게 통합할 수 있을까?

## 사무실 옆자리에서 들려온 이야기

- 리모컨이 협력 업체가 제공한 클래스를 자세하게 알 필요가 없도록 만들면 되지 않을까?
- 커맨드 패턴
  - 요청하는 쪽과 그 작업을 처리하는 쪽을 분리
- 커맨드 객체(command object)를 추가

## 커맨드 패턴 소개

- 객체 마을 식당
  - 고객
  - 웨이트리스
  - 주문
  - 주방장

### 음식 주문 과정

- 1. 고객이 종업원에게 주문을 합니다
  - createOrder()
- 2. 종업원은 주문을 받아서 카운터에 전달하고 "주문 들어왔어요!"라고 얘기합니다
  - takeOrder()
  - orderUp()
    - makeBurger() 같은 것들을 지시합니다
- 3. 주방장이 주문대로 음식을 주문합니다
  - makeBurger()
  - makeShake()

## 객체마을 식당 등장인물의 역할

### 주문서는 주문 내용을 캡슐화합니다

- 주문서 : 주문 내용을 요구하는 객체
- orderUp() 메소드가 들어 있음

### 종업원은 주문서를 받고 orderUp() 메소드를 호출합니다

### 주방장은 식사를 준비하는데 필요한 정보를 가지고 있습니다

## 객체마을 식당과 커맨드 패턴

#### 1. 클라이언트 - createCommandObject()

- 클라이언트는 커맨드 객체를 생성
  - 커맨드 객체는 리시버에 전달할 일련의 행동으로 구성된다

#### 2. 커맨드 - execute()

- 커맨드 객체에는 행동과 리시버의 정보가 같이 들어있습니다
  - action1()
  - action2()

```ts
class Command {
  // ...
  execute() {
    receiver.action1();
    receiver.action2();
  }
}
```

- 커맨드 객체에서 제공하는 메소드는 execute() 하나뿐입니다
- execute()
  - 행동 캡슐화
  - 리시버에 있는 특정 행동을 처리

#### 3. 인보커 - setCommand()

- 인보커
- 클라이언트는 인보커(Invoker) 객체의 setCommand() 메소드를 호출하는데, 이때 커맨드 객체를 넘겨줍니다.
- 그 커맨드 객체는 나중에 쓰이기 전까지 인보커 객체에 보관됩니다
- 리모컨

#### 4. 커맨드 - execute()

- 인보커에서 커맨드 객체의 execute() 메소드를 호출하면

#### 5. 리시버 - action1(), action2()

- 각 기기

#### 인보커 로딩

1. 클라이언트에서 커맨드 객체 생성
2. setCommand()를 호출해서 인보커에 커맨드 객체를 저장
3. 나중에 클라이언트에서 인보커에게 그 명령을 실행하라고 요청

## 첫 번째 커맨드 객체 만들기

## 커맨드 객체 사용하기
