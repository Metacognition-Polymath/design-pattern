# 7. 어댑터 패턴과 퍼사드 패턴 - 적응 시키기

- 데코레이터 패턴은 객체를 래퍼로 감싸서 새로운 역할을 부여
- 이번엔 실제와 다른 인터페이스를 가진 것처럼 보이도록 객체를 감싸보자
  - 특정 인터페이스가 필요한 디자인을 다른 인터페이스를 구현하는 클래스에 적응시킬 수 있기 때문
- 객체를 감싸서 인터페이스를 단순화할 수 있는 패턴도 알아보자

## 어댑터 살펴보기

- 어댑터 : 플러그 모양을 바꿔줌

  - 소켓의 인터페이스를 플러그에서 필요로 하는 인터페이스로 바꿔준다

- 객체지향 어댑터
  - 일상생활에서 쓰이는 어댑터와 똑같은 역할을 해야 함
  - 어떤 인터페이스를 클라이언트에서 요구하는 형태로 적응시키는 역할

## 객체지향 어댑터 알아보기

- 기존 시스템 : '>'
- 어댑터: '>)'
- 업체에서 제공한 클래스: ')]'

## 어댑터 사용 방법 알아보기

## 어댑터 패턴 알아보기

### 클라이언트에서 어댑터를 사용하는 방법

- 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청을 보냅니다
- 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 (하나 이상의) 메소드 호출로 변환합니다
- 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모릅니다

## 무엇이든 물어보세요

Q1) 어댑터가 얼마나 적응 시켜줘야 하나요? 대형 타깃 인터페이스를 구현해야 한다면 할 일이 정말 많아질 것 같은데요?

- 어댑터 구현은 타깃 인터페이스로 지원해야 하는 인터페이스의 크기에 비례해서 복잡해진다
- 클라이언트에서 호출하는 부분을 새로운 인터페이스에 맞추처서 고치려면 정말 많은 부분을 고쳐야 한다
- 이보단 캡슐화할 클래스 하나만 제공하는 방법이 더 낫다

Q2) 하나의 어댑터는 하나의 클래스만 감싸야 하나요?

- 어댑터 패턴은 하나의 인터페이스를 다른 인터페이스로 변환하는 용도
- 대부분의 어댑터 패턴 예제에서는 한 어댑티 클래스를 감싸지만, 실무에선 그리 간단하진 않다
- 하나의 어댑터에서 타깃 인터페이스를 구현하려고 2개 이상의 어댑티를 감싸야 하는 상황도 생길 수 있다
  - 2개 이상은 퍼사드 패턴과 관련이 있다
  - 많은 사람들이 두 패턴을 혼동하지만 잠시 후에 퍼사드 패턴을 배울 때 다시 이야기 해보자

Q3) 제가 가지고 있는 시스템에 오래된 부분과 새로 만든 부분이 섞여 있으면 어떻게 하죠?
어떤 곳에는 어댑터를 사용하고 다른 곳에는 어댑터로 감싸지 않은 인터페이스를 사용하면 햇갈리지 않을까요?
이런 경우에는 그냥 어댑터를 쓰지 않고, 기존 코드를 고쳐야 할까요?

- 굳이 고칠 필요없이 그런 상황에선 두 인터페이스를 모두 지원하는 다중 어댑터(Two way adapter)를 만들면 된다
- 다중 어댑터로 필요한 인터페이스를 둘 다 구현해서 어댑터가 기존 인터페이스와 새로운 인터페이스 역할을 할 수 있게 하면 된다

## 어댑터 패턴의 정의

- 어댑터 패턴(Adapter Pattern)은 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다
- 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와줍니다

- 어댑터 패턴을 사용하면 호환되지 않는 인터페이스를 사용하는 클라이언트를 그대로 활용할 수 있습니다
- 어댑터 패턴은 객쳋지향 원칙을 반영
  - 어댑티를 새로 바뀐 인터페이스로 감쌀 때는 객체 구성(composition)을 사용합니다
- 이런 접근법은 모든 서브클래스에 어댑터를 쓸 수 있다는 장점이 있습니다
- 이 패턴은 클라리언트를 특정 구현이 아닌 인터페이스에 연결합니다
- 서로 다른 백엔드로 코딩했기에 타깃 인터페이스만 제대로 유지한다면 나중에 다른 구현을 추가하는 것도 가능합니다
