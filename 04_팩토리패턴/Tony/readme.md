# 4. 객체지향 빵 굽기 - 팩토리 패턴

- 느슨한 결합으로 객체지향 디자인을 만들어 봅시다
  - 객체의 인스턴스를 만드는 작업이 항상 공개되어야 하는 것은 아니며,
  - 오히려 모든 것을 공객했다가는 결합 문제가 생길 수 있다는 사실을 배웁니다
- 팩토리 패턴으로 불필요한 의존성을 없애서 결합 문제를 해결하는 방법을 알아봅시다

- `new` 연산자가 눈에 띈다면 `구상`이라는 용어를 떠올려 주세요
  - new를 사용하면 구상 클래스의 인스턴스가 만들어집니다
  - 인터페이스가 아닌 특정 구현을 사용하는 것
  - 구상 클래스를 바탕으로 코딩하면 나중에 코드를 수정해야 할 가능성이 커지고, 유연성이 떨어진다

```ts
const duck: Duck = new MallardDuck();
```

- Duck 이란 인터페이스를 써서 코드를 유연하게 만들려고 합니다

- 열련의 구상 클래스가 있다면 어쩔 수 없이 다음과 같은 코드를 만들어야 합니다

```ts
let duck: Duck;
if (picnic) {
  duck = new MallardDuck();
} else if (hunting) {
  duck = new DecoyDuck();
} else if (inBathTub) {
  duck = new RubberDuck();
}
```

- 구상 클래스의 인스턴스가 여러 개 있으며,
- 그 인스턴스의 형식은 실행 시에 주어진 조건에 따라 결정됨
- 이런 코드를 변경하거나 확장해야 할 때는 코드를 다시 확인하고 새로운 코드를 추가하거나 기존 코드를 제거해야 함

  - 관리와 갱신이 어려워지고 오류가 생길 가능성도 커짐

- 인터페이스에 맞춰서 코딩하면 시스템에서 일어날 수 있는 변화에 대응할 수 있다
  - 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용할 수 있기 때문
- 반대로 구상클래스를 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하므로 수많은 문제가 생길 수 있다

- 즉, 변경에 닫혀 있는 코드가 된다
- 새로운 구상형식을 써서 확장해야 할 때는 어떻게 해서든 다시 열 수 있게 만들어야 한다

  - OCP, 확장에는 열려있고 변경에는 닫혀 있어야 한다

- 첫 번째 디자인 원칙, 바뀌는 부분을 찾아내서 바뀌지 않는 부분과 분리해야 한다
- 어떻게 하면 애플리케이션에서 구상 클래스의 인스턴스 생성 부분을 전부 찾아내서 애플리케이션의 나머지 부분으로부터 분리(캡슐화)할 수 있을까요?

## 최첨단 피자 코드 만들기

## 피자 코드 추가하기

## 객체 생성 부분 캡슐화하기

## 객체 생성 팩토리 만들기

## 무엇이든 물어보세요

## 클라이언트 코드 수정하기

## '간단한 팩토리'의 정의

## 다양한 팩토리 만들기

## 피자 가게 프레임워크 만들기

- 공통 팩토리 : oderPizza(type: string) 메소드 -> 내부적으로 createPizza(type) 메서드를 사용
- 각 지점별 팩토리 : abstract createPizza(type: string) 추상 메소드
  - 여기에서 type에 string을 제한해야되지 않을까 -> 고민해보자

## 서브클래스가 결정하는 것 알아보기

## 피자 스타일 서브클래스 만들기

## 팩토리 메소드 선언하기

## 피자 팩토리 메소드로 피자 주문하기

## 피자가 만들어지기까지

- PizzaStore 인스턴스 확보
  - 조엘 : ChicagoPizzaStore 인스턴스
  - 에단 : NYPizzaStore 인스턴스
- 각 PizzaStore 인스턴스에서 oderPizza를 호출
  - 이때 oderPizza의 파라미터로 메뉴를 알려줘야 함(치즈피자, 야채피자 등)
- oderPizza에선 createPizza메소드가 호출 됨
  - createPizza메소드는 PizzaStore 인스턴스(ChicagoPizzaStore, NYPizzaStore)에 정의되어 있음

## 피자가 만들어지기까지

```ts
// 1. 에단이 주문한 내역을 따라가 봅시다 우선 NYPizzaStore가 필요합니다
const nyPizzaStore = new NYPizzaStore();

// 2. 피자 가게가 확보됐으니 이제 주문을 받을 수 있습니다
nyPizzaStore.orderPizza("cheese");

// 3. orderPizza() 메소드에서 createPizza() 메소드를 호출합니다
const pizza = createPizza("cheese");

// 4. 아직 준비가 되지 않은 피자를 받았습니다 이제 만드는 작업을 마무리해야겠죠
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
```

## Pizza 클래스 만들기

## 최첨단 피자 코드 테스트
