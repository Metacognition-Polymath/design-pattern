# 디자인 패턴 소개와 전략 패턴

- 디자인 패턴의 세계로 떠나기

- 디자인 패턴?

  - (위키백과) 소프트웨어 설계에서 공통적인 문제에 대한 표준적인 해법

- 누군가 이미 여러분의 `문제를 해결`해 놓았습니다

  - 여러분과 똑같은 문제를 `경험`하고 해결하면서 익혔던 지혜와 교훈을 살펴보고,
    그것을 어떻게 활용할 수 있는지를 배웁니다
  - 디자인 패턴의 활용 분야와 디자인 패턴으로 얻을 수 있는 장점을 알아봅시다
  - 몇 가지 핵심적인 디자인 원칙을 살펴본 후
    - 한 가지 패턴을 정해 디자인 원칙이 어떤 식으로 작동하는지 알아보겠습니다
  - 디자인 패턴을 잘 사용 -> 패턴을 머리속에 -> 어플리케이션에 적용
  - 디자인 패턴은 코드가 아닌 경험을 재사용하는 것

- 나) 문제의 유형들에 대해 파악하고, 그 해법(디자인패턴)을 익히는 것 같다

## 오리 시뮬레이션 게임, SimUDuck

- 조는 SimUDuck 이라는 오리 시뮬레이션 게임을 만드는 회사에 다니고 있다
- 이 게임에서 오리
  - 헤엄 치고
  - 꽥꽥 소리도 냄

## 오리 시뮬레이션 게임 차별화 하기

- 다른 오리 시뮬 게임과 차별화 하기 위해 날 수 있도록 함
- Duck 클래스에 fly 메소드를 추가

## 경고! 심각한 문제 발생

- Duck의 몇몇 서브클래스만 날아야 하는데 모든 서브 클래스에 추가 됨
  - 고무 오리도 날아다니는 버그 발생
- 유지보수를 생각하면 상속은 좋은 방법은 아님

## 상속을 생각하기

- 날지 못하는 오리는 fly를 오버라이드해서 아무것도 하지 않도록 함
- DecoyDuck : 날 수도 소리 낼 수도 없는 오리 추가
  - 해당 메서드들을 오버라이드해서 아무것도 하지 않게 함

## 인터페이스 설계하기

- 상속은 올바른 해결책이 아닙니다 !
- 상속을 계속 활용한다면 규격이 바뀔 때 마다 프로그램에 추가했던 Duck의 서브클래스들의
  fly와 quack 메소드를 일일이 살펴보고 상황에 따라 오버라이드해야 함
- 더 깔끔한 방법?
  - Flyable 인터페이스를 구현해서 fly 메서드를 넣는다?
  - Quackable 인터페이스를 구현도 구현한다
- 단점
  - 메소드 오버라이드 피하려다가 fly가 바뀌면 인터페이스를 받는 모든 서브클래스 코드를 다 고쳐야 함

## 해결 방법 고민하기

- 모든 서브 클래스에서 날거나 꽥꽥거리는 기능이 필요한 것은 아니므로 상속은 올바른 방법이 아님
- 인터페이스를 받아서 서브클래스에서 구현할 수 있지만
  - 코드를 재사용하지 않아서 관리가 어려움
- 구식이긴 하지만 좋은 객체지향 소프트웨어 디자인 원칙을 적용해보자

## 소프트웨어 개발 불변의 진리

- 소프트웨어 개발에서 절대로 바뀌지 않는 진리는 무엇일까요?
  - 변화
  - 아무리 디자인을 잘한 애플리케이션이라도 시간이 지남에 따라 변화하고 성장해야 한다

## 문제를 명확하게 파악하기

- 상속이 성공적인 해결책이 아니라는 사실은 이제 확실히 안다
- 인터페이스는 코드 재사용을 하지 않는다

### 디자인 원칙

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다

  - 여러 디자인 원칙 가운데 첫 번째 원칙

- 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 `캡슐화` 합니다

  - 그러면 코드를 변경하는 과정에서 의도치 않게 발생하는 일을 줄이면서 시스템의 유연성을 향상싵킬 수 있습니다

- 바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고
  그 부분만 고치거나 확장할 수 있다
  - 모든 디자인 패턴의 기반을 이루는 원칙
    - 모든 패턴은 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는 방법을 제공

## 바뀌는 부분과 그렇지 않은 부분 분리하기

- 바뀌는 부분 : fly, quack
  - 바뀌는 부분 각각 집합으로 만듦
    - 별도의 클래스 집합으로 분리
    - 분리한 각각의 클래스엔 다양한 메소드 구현이 들어감
  - 나는 행동
  - 꽥꽥 거리는 행동

## 오리의 행동을 디자인하는 방법

- 나는 행동과 꽥꽥 거리는 행동을 구현하는 클래스 집합은 어떻게 디자인해야 할까요?

### 두 번째 디자인 원칙

- 구현보다는 인터페이스에 맞춰서 프로그래밍한다

- 새로운 디자인(행동을 분리한 집합)
  - FlyBehavior같은 구체적인 행동은 Duck의 서브클래스에 국한되지 않음

### '인터페이스에 맞춰서 프로그래밍한다'라는 말은 사실 '상위 형식에 맞춰서 프로그래밍한다'라는 말

- 인터페이스는 항상 인터페이스를 쓰라는 말은 아님
- 상위형식에 맞춰서
  - 변수를 선언할 때 추상클래스나 인터페이스 같은 상위 형식으로 선언해야 한다
  - 객체를 변수에 대입할 때 상위형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있기 때문
  - 변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다
- Animal.ts 참고

### 오리의 행동을 구현하는 방법

- 행동 인터페이스 -> 행동 클래스 각각 구현
- 이런식으로 디자인하면 다른 형식의 객체에서도 나는 행동과 꽥꽥거리는 행동을 재사용할 수 있음
  - 그런 행동이 더 이상 Duck 클래스 안에 숨겨져 있지 않기 때문
- 그리고 기존 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck 클래스를 전혀 건드리지 않고도
  새로운 행동을 추가할 수 있음
- 따라서 상속을 쓸 때 떠안게 되는 부담을 전부 떨쳐버리고
  재사용의 장점을 그대로 누릴 수 있음

## 무엇이든 물어보세요

- 행동만 나타내는 클래스?
  - 클래스는 일반적으로 상태와 메소드를 둘 다 가지고 있음
  - 그런데 이 경우에는 클래스가 '행동'을 가지고 있음
  - 행동에도 여전히 상태와 메소드가 들어있을 수 있습니다
    - e.g.
      - 날아가는 행동 속성(상태)
        - 1분당 날개를 펄럭이는 횟수
        - 최고 높이
        - 속도 등

## 오리 행동 통합하기

- 가장 중요한 점
  - 날아가는 행동과 꽥꽥거리는 행동을 Duck 클래스에서 정의한 메소드를 써서 구현하지 않고 다른 클래스에 위임하는 것

### 잠깐만요

- 잠깐만요! 특정 구현에 맞춰서 프로그래밍하면 안된다고 하지 않았나요?
  - MallardDuck의 생성자를 보면 Quack이라는 구현되어 있는 구상 클래스의 인스턴스를 만들었잖아요!
- 좋은 지적입니다
  - 실행 시 동적으로 QuackBehavior를 구현한 다른 클래스를 할당할 수 있게 바꿀 수 있습니다
  - 이 뒤에 나오는 `동적으로 행동 지정하기` 참고

## 오리 코드 테스트

## 동적으로 행동 지정하기

- Duck 클래스에 선언된 fly, quack 행동이 동적으로 결정될 수 있게 만들어놓고 활용하지 못하고 있다
- setter method로 동적으로 설정할 수 있게 해보자

## 캡슐화된 행동 살펴보기

- 지금까지 한 것
  - 오리에서 변하는 행동을 분리해서 그룹으로 관리
- 이번엔 생각방식을 조금 바꿔보자
  - 오리의 행동들을 일련의 행동으로 생각하는 대신
  - 알고리즘군(family of algorithms)으로 생각해보자
- SimUDuck게임 디자인에서 알고리즘은 오리가 하는 행동을 나타내지만, 지역에 따라 달라지는 세금 계산 방식을 구현하는 클래스에도 활용할 수 있습니다
- 클래스 사이의 관계
  - A는 B이다
  - A에는 B가 있다
  - A가 B를 구현한다
- 행동은 알고리즘으로 바뀔 수 있습니다

## 두 클래스를 합치는 방법

- `A에는 B가 있다`
  - 각 오리에는 `FlyBehavior`와 `QuackBehavior`가 있습니다
  - 이런식으로 두 클래스를 합치는 것을 `구성(composition)`을 이용한다라고 부릅니다
  - 구성은 매우 중요한 테크닉이자 세 번째 디자인 원칙이기도 합니다
- 'A는 B이다' 보다 'A에는 B가 있다'가 나을 수 있습니다

### 디자인 원칙 : 상속보다는 구성을 활용한다

- 구성은 여러 디자인 패턴에서 쓰이며, 앞으로 이 책 전반에 걸쳐서 구성의 장단점을 배웁니다
- 구성의 활용
  - 오리 소리를 내는 오리 호출기
    - Duck 클래스를 상속받지 않고 만들 수 있다

## 첫 번째 디자인 패턴: 전략 패턴

- SimUDuck 애플리케이션을 바꾸면서 배운 것이 전략패턴입니다

### 전략 패턴(Strategy Pattern)

- `알고리즘군`을 `정의`하고 `캡슐화`해서 각각의 알고리즘군을 `수정해서 쓸 수 있게` 해줍니다
- 전략 패턴을 사용하면 `클라이언트로부터 알고리즘을 분리`해서 `독립적으로 변경`할 수 있습니다
