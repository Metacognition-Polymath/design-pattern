# 3. 객체 꾸미기 - 데코레이터 패턴

- "상속맨, 디자인에 눈을 뜨다"

  - 상속을 남용하는 사례를 살펴보고
  - 객체 작성이라는 형식으로 실행 중에 클래스를 꾸미는(데코레이션하는) 방법을 배웁니다
  - 데코레이터 패턴을 배우면 기존 클래스 코드를 바꾸지 않고도 객체에 새로운 임무를 추가할 수 있습니다

- 서브 클래스 -> 실행 중에 확장이 어려움

## 초대형 커피 전문점, 스타버즈

- 주문 시스템 개선

#### 주문 시스템

```ts
abstract class Beverage {
  protected description: string;
  constructor() {}

  // description 값 반환
  getDEscription() {
    return this.description;
  }

  // 추상 메소드, 서브 클래스에서 이 메소드를 구현해서 새로 정의해야 함
  abstract cost(): number;
}
```

- 고객은 커피를 주문할 때 우유, 두유, 모카(초콜릿)을 추가하고 그 위에 휘핑크림을 얹기도 합니다
- 각 경우마다 서브클래스를 만들면 클래스가 '폭발', 너무 많아짐

#### 뇌단련

- 만약 우유 가격이 인상 되면?
- 캐러멜을 새로 추가하면?
- 클래스 관리를 생각해 볼 때, 지금까지 우리가 배웠던 디자인 원칙 가운데 무엇을 제대로 지키지 않고 있는 걸까요? (2가지)
  - 나) 상속보다는 구성을 활용한다
  - 나) 구현보다는 인터페이스에 맞춰서 프로그래밍한다

#### 지금까지 배운 디자인 원칙

- 바뀌는 부분은 캡슐화한다
- 상속보다는 구성을 활용한다
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다
- 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다

### 슈퍼 클래스 상속을 써서 첨가물 관리 예

- A) 클래스가 5개 밖에 안되잖아?
- B) 난 아직 확신이 서지 않는데..
  - 나중에 이 디자인이 어떻게 바뀔지 생각해보면 이 접근법의 문제점을 발견할 수 있을지도 몰라

### 쓰면서 제대로 공부하기

#### 이 프로젝트에서 변경되었을 때 디자인에 영향을 미칠만한 요소를 적어봅시다

- 첨가물 가격이 바뀔 때 마다 기존 코드를 수정해야 합니다
- 첨가물의 종류가 많아지면 새로운 메소드를 추가해야 하고, 슈퍼클래스의 cost() 메소드도 수정해야 합니다
- 새로운 음료가 출시될 수도 있습니다.
  - 그 중에선 특정 첨가물이 들어가면 안되는 음료도 있을 것입니다
  - 예를 들어 아이스 티를 생각해보면, Tea 서브 클래스에서도 hasWhip() 같은 메소드가 여전히 상속 받게 될 것입니다
    - 이건 꽤 심각한 문제입니다 !!
- 고객이 더블 모카를 주문하면 어떻게 해야 할까요?

### 스승과 제자

- 상속을 사용한다고 해서 유연하거나 관리하기 쉬운 디자인이 만들어지진 않는다
- 재사용 -> 구성과 위임으로 실행 중 `행동을 상속`하는 방법이 있다
- 서브 클래스를 만드는 방식으로 행동을 상속받으면 그 행동은 컴파일 할 때 완전히 결정 됨
  - 게다가 모든 서브클래스에서 똑같은 행동을 상속받아야 함
  - 하지만 `구성`으로 객체의 행동을 확장하면 실행 중에 `동적으로 행동을 설정`할 수 있음
- 구성
  - 객체에 여러 임무를 새로 추가할 수 있음
  - 클래스 코드를 전혀 건드리지 않고도 슈퍼클래스를 디자인할때 생각지 못 했던 내용을 추가할 수도 있음

## OCP 살펴보기

- OCP : Open-Closed Principle

  - 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다

- 디자인 원칙 - OCP

  - 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀야 한다

- 우리의 목표
  - 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것
  - 새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응하는 유연하고 튼튼한 디자인을 만들 수 있음

## 무엇이든 물어보세요

- 확장에는 열려 있고 변경에 닫혀있다

  - 코드를 변경하지 않아도 시스템을 확장하게 해주는 객체지향 기법들은 많다
    - 옵저버 패턴
      - 옵저버를 새로 추가하면 주제(Subject)에 코드를 추가하지 않으면서 확장할 수 있음

- 옵저버 패턴 외 코드를 변경하지 않으면서 확장이 용이한 디자인을 쉽게 만들 수 있나요?

  - 확장할 때 코드를 직접 수정하는 것을 방지하는 디자인 기법들이 있다
  - 3장에선 데코레이터 패턴으로 OCP를 준수하는 방법을 배웁니다

- 모든 부분에서 OCP를 준수하려면 어떻게 해야 하나요?

  - 모든 부분은 불가능
  - OCP를 준수하는 객체 지향 디자인을 만들려면 적지 않은 시간과 노력이 필요
  - 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않음
  - OCP를 지키다보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데,
    - 추상화를 하다보면 코드가 복잡해짐
  - 우리가 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋습니다

- 바뀌는 부분 중에서 OCP를 적용할 만큼 중요한 부분을 어떻게 골라낼 수 있죠?

  - 객체지향 디자인 경험 + 도메인 지식
  - 여러 디자인을 살펴보면 바뀌는 부분 가운데 중요한 부분을 골라내는 안목이 높아집니다

- OCP 주의 사항
  - 코드를 확장해야 할 부분을 선택할 때는 세심한 주의를 기울여야 합니다
  - 무조건 OCP를 적용한다면 괜히 쓸데 없는 일을 하며, 코드를 복잡하게 만들 수 있습니다

## 데코레이터 패턴 살펴보기

- 상속을 써서 음료 가격과 첨가물 가격을 합해서 총 가격을 산출하는 방법은 좋은 방법이 아니었다
  - 클래스가 어마어마 하게 많아지거나 일부 서브클래스에는 적합하지 않은 기능을 추가해야 하는 문제가 있음
- 다른 방법을 생각해보자
- 특정 음료에서 시작해서 첨가물로 그 음료를 장식(decorate) 해보자

  - e.g. 모카와 휘핑 크림을 추가한 다크 로스트 커피
    - DarkRoast 객체를 가져온다
    - Mocha 객체로 장식한다
    - Whip 객체로 장식한다
    - cost() 메소드를 호출한다
      - 이때 첨가물의 가격을 계산하는 일은 해당 객체에 위임한다

- 객체를 어떻게 장식할 수 있을까요?
- 이 과정에서 어떤 식으로 위임할 수 있을까요?
- 데코레이터 객체를 '래퍼(wrapper)' 객체라고 생각해보세요

## 주문 시스템에 데코레이터 패턴 적용하기

1. DarkRoast 객체에서 시작

- Beverage로 부터 상속받음
- cost() 메소드를 가지고 있음

2. 고객이 모카를 주문했으므로 Mocha 객체를 만들고 그 객체로 DarkRoast를 감쌉니다

- 같은 형식을 갖는다
- Mocha도 Beverage의 서브클래스 형식
- Mocha도 cost() 메소드가 있음

3. 고객이 휘핑크림도 추가했으나까 Whip 데코레이터를 만들어 Mocha를 감쌉니다

- Whip도 Beverage의 서브클래스 형식
- Whip도 cost() 메소드를 가지고 있음

4. cost() 메소드 호출

- 가장 바깥쪽에 있는 Whip의 cost()를 호출하면 됩니다

### 지금까지 배운 내용 정리

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다
  - DarkRoast와 Whip 모두 Beverage 이다
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관 없다
- _데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가작업을 수행할 수 있다_
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있다

## 데코레이터 패턴의 정의

- 데코레이터 패턴(Decorator Pattern)으로 객체에 추가 요소를 동적으로 더할 수 있습니다
- 데코레이터를 사용하면 서브클래스를 만들 때 보다 훨씬 유연하게 기능을 확장할 수 있습니다

```ts
abstract class Component {
  methodA()
  meThodB()
}

class ConcreteComponent extends Component {
  methodA() {
   // 새로운 행동을 동적으로 추가
   const defaultA = super.methodA();
   const newA = 'do something new'
    return defaultA + newA
  }
  meThodB()
}

// 데코레이터는 자신이 장식할 구성요소와 같은 인터페이스 또는 추상 클래스를 구현
class Decorator extends Component {
  protected wrappedObj: Component; // 자신이 장식할 구성요소와 같은 인터페이스 또는 추상 클래스룰 구현

  methodA()
  methodB()
}

class ConcreteDecoratorA() extends Decorator{
  methodA()
  methodB()
  newBehavior() {
    // 새로운 메소드 : 보통 원래 있던 메소드를 호출 후 별도의 작업으로 처리해서 새로운 기능을 추가
    const defaultA = this.methodA();
    const defaultB = this.methodB();
    // do something new
    return somethingNew;
  }
}

class ConcreteDecoratorB() extends Decorator{
  private newState // 상태를 확장할 수 있음

  methodA()
  methodB()
}
```

## Beverage 클래스 장식하기

- 스타버즈 커피에 새로운 프레임 워크를 적용해봅시다

```ts
abstract class Beverage {
  protected description;

  getDescription();
  cost();
}

class DarkRoast extends Beverage {
  cost();
}

class CondimentDecorator extends Beverage {
  getDescription();
}

class Milk extends CondimentDecorator {
  cost();
  getDescription();
}
```

### 사무실 옆자리에서 들려온 이야기

- 의문점

  - 상속 대신 구성을 사용할 줄 알았는데..
  - 1장에서 배운 디자인 원칙과 다른데..

- CondimentDecorator에서 Beverage 클래스를 상속하고 있는데?
- 데코레이터 형식이 그 데코레이터로 `감싸는 객체의 형식과 같다`는 점이 중요한 부분
  - 상속을 사용해서 형식을 맞춤
  - 상속으로 행동을 물려받는게 아니니까 괜찮다
- 데코레이터 객체가 자신이 감싸고 있는 객체랑 같은 인터페이스를 가져야 하는 이유
  - 원래 있던 구성 요소가 들어갈 자리에 자기가 들어갈 수 있어야 하기 때문
  - 행동은 어디서 오는 거지?
- 어떤 구성요소를 가지고 `데코레이터`를 만들 때 `새로운 행동을 추가`함
  - 데코레이터에서 새로운 행동을 추가한다
- `상속을 받는 이유`는 행동을 상속받으려는 것이 아니라 `형식을 맞추려고 한 것`
- 책에선 추상클래스를 사용했는데 인터페이스를 쓰는 경우가 많고 추상클래스를 써도 된다는 것을 보여주려는 것

## 데코레이터 패턴 적용 연습

- 더블 모카
  - 모카 데코레이터를 두번 감싼다(나는 addMocha 메서드를 추가할 것으로 생각했지만 아니었다)

## 커피 주문 시스템 코드 만들기

## 음료 코드 구현하기

## 첨가물 코드 구현하기

## 커피 주문 시스템 코드

- 나중에 팩토리와 빌더 패턴을 배울 때 이런 객체를 만드는 더 나은 방법을 알아보겠습니다.
  - 빌더 패턴은 14장에서 다룹니다
