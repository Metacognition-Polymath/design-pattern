# 10. 상태 패턴 - 객체의 상태 바꾸기

- 전략 패턴과 상태 패턴은 쌍둥이입니다(객체가 행동을 바꿀 수 있게 함)
  - 전략 패턴 : 알고리즘을 변경
  - 상태 패턴 : 내부 상태를 변경
- 설계는 거의 같지만 그 용도가 다를 수 있다. 알아보자!

## 최첨단 뽑기 기계

- 뽑기 기계에 소프트웨어를 추가
  - 재고 조사 등 데이터 수집용

### 상태 다이어 그램

- `동전 없음`

  - 동전 투입 -> 동전 있음

- `동전 있음`

  - 동전 반환 -> 동전 업음
  - 손잡이 돌림 -> 알맹이 판매

- `알맹이 판매`

  - 알맹이 내보냄
    - 알맹이 > 0 -> 동전 없음
    - 알맹이 = 0 -> 알맹이 매진

- `알맹이 매진`

## 사무실 옆자리에서 들려온 이야기

- `상태` : 기계가 어떤 식으로 설정되어 있는지를 나타냄

  - 동전 없음
  - 동전 있음
  - 알맹이 판매

- 행동 : 다른 상태로 넘어가는 전환 종류
  - 동전 투입
  - 동전 반환
  - 손잡이 돌림
  - 알맹이 내보냄
    - 알맹이 > 0
    - 알맹이 = 0

## 상태 기계 기초 지식 알아보기

### 상태 기계를 구현하는 방법을 살펴보자

1. 상태들을 모아보자

   - 동전 없음
   - 동전 있음
   - 알맹이 매진
   - 알맹이 판매

2. 현재 상태를 저장하는 인스턴스 변수를 만들고 각 상태의 값을 정의합니다.

```java
final static int SOLD_OUT = 0;
final static int NO_QUARTER = 1;
final static int HAS_QUARTER = 2;
final static int SOLD = 3;

int state = SOLD_OUT;
```

- enum을 사용하면 더 좋을 것 같다

```ts
// Typescript enum을 사용해서 상태를 정의
enum State {
  SOLD_OUT = 0,
  NO_QUARTER = 1,
  HAS_QUARTER = 2,
  SOLD = 3,
}

let state = State.SOLD_OUT;
```

3. 이 시스템에서 일어날 수 있는 모든 행동을 모아 봅니다
   - 동전 투입
   - 동전 반환
   - 손잡이 돌림
   - 알맹이 내보냄

- 여기에 있는 행동들은 뽑기 기계의 인터페이스라고 할 수 있습니다

4. 이제 상태 기계 역할을 하는 클래스를 만들어보자

- 각 행동을 구현할 때는 조건문을 써서 상태별로 어떤 작업을 처리해야 할지 결정합니다
- 예를 들어, '동전 투입' 행동은 다음과 같은 메소드로 처리할 수 있다

```ts
const insertQuarter = () => {
  if (state === State.SOLD_OUT) {
    console.log("매진되었습니다. 다음 기회에 이용해주세요.");
  } else if (state === State.NO_QUARTER) {
    console.log("동전이 투입되었습니다.");
    state = State.HAS_QUARTER;
  } else if (state === State.HAS_QUARTER) {
    console.log("동전은 한 개만 넣어주세요.");
  } else if (state === State.SOLD) {
    console.log("알맹이를 내보내고 있습니다.");
  }
};
```

- 상태 기계를 구현할 때 이런 기법을 많이 사용합니다.
- 상태값을 저장하는 인스턴스 변수를 만들고, 메소드 내에서 조건문을 써서 다양한 상태를 처리합니다.

## 뽑기 기계 코드 만들기

## 알림! 뽑기 기계 코드 수정 요청

- 10% 확률로 알맹이가 2개 나오도록 수정

## 요청 사항 살펴보기

- 처음에 만들었던 코드는 꽤 훌륭하다고 생각했는데, 새로운 기능을 추가해 달라는 요청을 받고 보니 확장이 어렵겠군요

### 리팩토링

- 바뀌는 부분은 캡슐화한다
- 상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현하면 어떨까요?
  - 뽑기 기계가 현재 상태를 나타내는 사아태 객체에게 작업을 넘기게 하면 된다
- 구성을 활용하라는 원칙을 적용하는 셈

## 새로운 디자인 구상하기

- 기존 코드를 그대로 활용하는 대신, 상태 객체들을 별도의 코드에 넣고, 어떤 행동이 일어나면 현재 상태 객체에서 필요한 작업을 처리

### 계획 정리

1. 뽑기 기계와 관련된 모든 행동에 관한 메소드가 들어있는 State 인터페이스를 정의해야 합니다
2. 그 다음에는 기계의 모든 상태를 대상으로 상태 클래스를 구현해야 합니다
   - 기계가 어떤 상태에 있다면, 그 상태에 해당하는 상태 클래스가 모든 작업을 책임져야 하죠
3. 마지막으로 조건문 코드를 전부 없애고 상태 클래스에 모든 작업을 위임합니다.

- 기존에 배웠던 디자인 원칙들을 따르면서 `상태 패턴`이라는 새로운 패턴을 구현하게 되었습니다.
- 상태 패턴의 정의는 우선 이 디자인을 코드로 만들어 본 다음 자세히 알아보겠습니다.

## State 인터페이스 및 클래스 정의하기

```ts
// 우선 모든 상태 클래스에서 구현할 State 인터페이스를 만들어 봅시다
interface State {
  insertQuarter(): void;
  ejectQuarter(): void;
  turnCrank(): void;
  dispense(): void;
}

// 디자인에 들어있는 모든 상태를 캡슐화해서 State 인터페이슬 구현하는 클래스를 만듭니다
interface SoldState extends State {
  // ...
}

interface SoldOutState extends State {
  // ...
}

interface NoQuarterState extends State {
  // ...
}

interface HasQuarterState extends State {
  // ...
}

// 당첨을 나타내는 상태는 새로운 디자인에 맞게 다시 구현한 후에 생각해보자
```

- 각 상태에 따라 메소드가 호출 되었을 때 무슨일을 해야 하는지 생각해 봐야 합니다

### 각 상태에 따른 행동 정의하기

- NoQuarterState

  - insertQuarter() : HasQuarterState로 전환
  - ejectQuarter() : 동전을 넣어 달라는 메세지를 출력
  - turnCrank() : 손잡이를 돌렸지만 동전이 없다는 메시지를 출력
  - dispense() : 동전을 넣어야 한다는 메시지를 출력

- HasQuarterState

  - insertQuarter() : 동전을 두 개 넣을 수는 없다는 메시지를 출력
  - ejectQuarter() : 동전을 반환하고 NoQuarterState로 전환
  - turnCrank() : SoldState로 전환
  - dispense() : 알맹이가 나가지 않았다는 메시지를 출력

- SoldState

  - insertQuarter() : 알맹이를 내보내고 있으니 기다려 달라는 메시지를 출력
  - ejectQuarter() : 이미 손잡이를 돌렸다는 메시지를 출력
  - turnCrank() : 한 번만 돌려 달라는 메시지를 출력
  - dispense() : 알맹이를 하나 내보냄. 이때 알맹이 개수를 확인하고
    - 알맹이 개수가 0보다 크면 NoQuarterState로 전이
    - 알맹이 개수가 0이면 SoldOutState로 전이

- SoldOutState

  - insertQuarter() : 알맹이가 없다는 메세지를 출력
  - ejectQuarter() : 동전을 넣지 않았다는 것을 알림
  - turnCrank() : 알맹이가 없다는 메세지를 출력
  - dispense() : 알맹이가 나가지 않았음을 알림

- WinnerState
  - insertQuarter() : 알맹이를 내보내고 있으니 기다려 달라는 메시지를 출력
  - ejectQuarter() : 이미 손잡이를 돌렸다는 메시지를 출력
  - turnCrank() : 알맹이를 내보내고 있으니 기다려 달라는 메시지를 출력
  - dispense() : 알맹이를 두 개 내보냄.
    - 알맹이 개수가 0보다 크면 NoQuarterState로 전이
    - 알맹이 개수가 0이면 SoldOutState로 전이

## State 클래스 구현하기

- 상태를 구현해보자
- 각 메소드에서 어떤 일을 해야 하는지 정리했으니 코딩만 하면 됩니다
- 전에 만들었던 상태 코드와 거의 비슷하게 만들면 되지만 이번에는 모든 코드가 서로 다른 클래스에 분산됩니다

## 뽑기 기계 코드 수정하기

## 뽑기 기계 전체 코드 살펴보기

## 다른 상태 클래스 구현하기

## 뽑기 기계 구조 다시 살펴보기

- 리팩터링한 GumballMachine 클래스의 구조는 완전히 달라졌지만 기능 면에서 보면 완전히 같다
- 구현을 구조적으로 바꿈으로써 다음과 같은 결과를 얻을 수 있었습니다

  - 각 상태의 행동을 별개의 클래스로 국지화했습니다
  - 관리하기 힘든 골칫덩어리 if 선언문들을 없앴습니다
  - 각 상태를 변경에는 닫혀 있게 했고, GumballMachine 클래스는 새로운 상태 클래스를 추가하는 확장에는 열려 있도록 고쳤습니다.(OCP)
  - 주식회사 왕뽑기에서 처음 제시했던 다이어그램에 훨씬 가까우면서 더 이해하기 좋은 코드 베이스와 클래스 구조를 만들었습니다

- 기능적인 면에서 조금 더 자세히 살펴봅시다
  - 뽑기 기계에는 상태 클래스의 인스턴스가 들어있습니다
  - 기계의 현재 상태는 항상 이 클래스들 중 하나입니다

## 상태 패턴의 정의

- 상태 패턴(State Pattern)을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있습니다
- 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있습니다
- 이 패턴은 상태를 클래스로 캡슐화한 다음 현재 상태를 나타내는 객체에게 행동을 위임하므로 내부 상태가 바뀔 때 행동이 달라지게 된다

- 클래스를 바뀌는 것 같은 결과를 얻는다
  - 클라이언트 관점
    - 만약 지금 사용하고 있는 객체의 행동이 달라진다면 다른 클래스로 부터 만들어진 것 처럼 느껴질 것이다

![](./images/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4_%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8.jpeg)

#### 상태 패턴 vs 전략 패턴

- 상태 패턴과 전략 패턴의 다이어그램은 똑같습니다
- 하지만 상태 패턴과 전략 패턴의 용도는 다릅니다

#### 상태 패턴

- 상태 패턴을 사용할 때는 상태 객체에 일련의 행동이 캡슐화 됩니다
- 상황에 따라 Context 객체에서 여러 상태 객체 중 한 객체에게 모든 행동을 맡기게 되죠
- 그 객체의 내부 상태에 따라 현재 상태를 나타내는 객체가 바뀌게 되고, 그 결과로 Context 객체의 행동도 자연스럽게 바뀌게 됩니다
- 클라이언트는 상태 객체를 몰라도 됩니다

#### 전략 패턴

- 전략 패턴을 사용할 때는 일반적으로 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지를 지정해 줍니다
- 전략 패턴은 주로 실행 시에 전략 객체를 변경할 수 있는 유연성을 제공하는 용도로 쓰이죠
- 보통 가장 적합한 전략 객체를 선택해서 사용하게 됩니다
- 예를 들어, 1장에는 특정한 방식으로 날아다니도록 설정된 오리와 날지 못하도록 설정된 오리가 등장했죠
- 이럴 때 각각 필요한 전략 객체를 지정해서 사용했습니다

- 일반적으로 전략 패턴은 서브 클래스를 만드는 방법을 대신해서 유연성을 극대화하는 용도로 쓰입니다
- 상속을 사용해서 클래스의 행동을 정의하다 보면 행동을 변경해야 할 때 마음대로 변경하기가 힘들죠
- 하지만 전략 패턴을 사용하면 구성으로 행동을 정의하는 객체를 유연하게 바꿀 수 있습니다

#### 상태 패턴 사용하기

- Context 객체에 수 많은 조건문을 넣는 대신에 상태 패턴을 사용한다고 생각하면 됩니다
- 행동을 상태 객체 내에 캡슐화하면 Context 내의 상태 객체를 바꾸는 것만으로도 Context객체의 행동을 바꿀 수 있으니까요

## 무엇이든 물어보세요

- Q1) GumballMachine 클래스를 보면 지금 상태로 다음 상태가 결정됐는데, 반드시 구상 상태 클래스에서 다음 상태를 결정해야 하나요?
- A1) 꼭 그래야 하는 건 아닙니다. Context에서 상태 전환 흐름을 결정하도록 할 수도 있습니다
  - 상태 전환이 고정되어 있으면 상태 전환 흐름을 결정하는 코드를 Context에 넣어도 됩니다
  - 하지만 상태 전환이 동적이라면 상태 객체에게 상태 전환 흐름을 결정하도록 하는 게 좋습니다
  - 예를 들어, GumballMachine에서 NoQuarter 또는 SoldOut으로 전환하는 결정은 실행 중에 남아 있는 알맹이의 개수에 따라 동적으로 결정될 수 밖에 없습니다
  - 상태 전환 코드를 상태 클래스에 넣으면 상태 클래스 사이에 의존성이 생기는 단점이 있습니다
  - GumballMachine 구현 코드를 보면 구상 상태 클래스를 코드에 직접 넣는 대신 Context 객체의 게터 메소드를 써서 의존성을 최소화하려고 노력했음을 알 수 있습니다
  - 상태 전환의 흐름을 결정하는 코드를 어느 쪽에 넣는지에 따라서 시스템이 점점 커지게 될 때, 어떤 클래스(Context 또는 상태 클래스)가 변경에 닫혀 있게 되는지도 결정됩니다

```ts
// Context => GumBallMachine
// State(상태 객체) => NoQuarterState, HasQuarterState, SoldState, SoldOutState
class GumballMachine {
  private state: State;
  private count: number;

  constructor(count: number) {
    this.count = count;
    if (count > 0) {
      this.state = new NoQuarterState(this);
    }
  }

  insertQuarter() {
    this.state.insertQuarter();
  }

  ejectQuarter() {
    this.state.ejectQuarter();
  }

  turnCrank() {
    this.state.turnCrank();
    this.state.dispense();
  }

  releaseBall() {
    console.log("알맹이가 나갑니다.");
    if (this.count !== 0) {
      this.count -= 1;
    }
  }

  getCount() {
    return this.count;
  }

  setState(state: State) {
    this.state = state;
  }

  // 구상 상태 클래스를 코드에 직접 넣는 대신 Context 객체의 게터 메소드를 써서 의존성을 최소화하려고 노력했음을 알 수 있습니다
  getNoQuarterState() {
    // A3) 상태 객체에서 Context에 있는 메소드 또는 인스턴스 변수를 활용해야 한다면 각 handle() 메소드에 Context 객체의 레퍼런스도 전달해야 합니다
    return new NoQuarterState(this);
  }

  getHasQuarterState() {
    return new HasQuarterState(this);
  }

  getSoldState() {
    return new SoldState(this);
  }

  getSoldOutState() {
    return new SoldOutState(this);
  }
}
```

- Q2) 클라이언트에서 상태 객체와 직접 연락하는 경우도 있나요?
- A2) 그런 일은 없습니다. 상태는 Context 쪽에서 내부 상태 및 행동을 표현하는 용도로 사용되므로 상태 요청은 전부 Context로 부터 오게 됩니다

  - 클라이언트는 Context의 상태를 직접 바꿀 수 없죠
  - 상태를 관리하는 일은 전적으로 Context가 책임져야 하며, Context 몰래 클라이언트가 직접 Context의 상태를 변경할 일은 없습니다

- Q3) 애플리케이션에 Context의 인스턴스가 아주 많은데요, 여러 Context에서 상태 객체를 공유할 수도 있나요?
- A3) 그럼요 당연히 됩니다. 실제로 그렇게 할 때도 많습니다

  - 상태 객체 내에 자체 상태를 보관하지 않아야 한다는 조건만 만족하면 상관 없습니다
  - 상태 객체 내에 자체 상태를 보관하려면 각 Context 마다 유일한 객체가 필요하니까요
  - 상태를 공유할 때는 일반적으로 각 상태를 정적 인스턴스 변수에 할당하는 방법을 씁니다
  - 상태 객체에서 Context에 있는 메소드 또는 인스턴스 변수를 활용해야 한다면 각 handle() 메소드에 Context 객체의 레퍼런스도 전달해야 합니다

- Q4) 상태 패턴을 사용하면 디자인에 필요한 클래스의 개수가 늘어나나요? GumballMachine의 클래스가 정말 많아진 것 같아서요
- A4) 네 맞습니다. 상태의 행동을 별도의 상태 클래스에 캡슐화 하다보면 클래스 개수가 늘어나기 마련이죠

  - 유연성을 향상시키려고 지불해야 할 비용이라고 생각하면 됩니다
  - 한 번만 쓰고 치워버릴 클래스가 아닌 이상 조금 귀찮아도 클래스를 추가해서 유연한 디자인을 만드는 것이 좋습니다
  - 나중에 분명히 그렇게 하길 잘 했다는 생각이 들 것입니다
  - 그리고 사실 대부분의 경우에 실제 클래스 개수보다는 클라이언트에게 노출 되는 클래스 개수가 중요하며, 나머지 클래스를 숨길 수 있는 방법도 있습니다
    - 패키지 내에서만 볼 수 있도록 선언
  - 그리고 상태 패턴을 쓰지 않고 여러 개의 클래스를 추가한다면 어떻게 될까요?
    - 애플리케이션을 만들 때 상태 클래스를 만들기 귀찮아서 상태 패턴을 쓰지 않는다면, 정말 복잡한 조건문을 사용해야 합니다
    - 그러면 코드를 관리하기도 힘들고, 이해하기도 힘들어지죠
    - 하지만 객체를 사용하면 상태를 확실하게 표현할 수 있기에 코드 이해는 물론, 관리도 쉬워집니다

- Q5) 상태 패턴 클래스 다이어그램을 보면 State가 추상 클래스로 되어있잖아요? 그런데 뽑기 기계의 상태에서는 왜 인터페이스를 쓴거죠?
- A5) 추상 클래스에 넣을 만한 공통적인 기능이 없었기에 그냥 인터페이스를 사용했습니다.
  - 하지만 State에 해당하는 클래스를 디자인할 때는 추상 클래스 사용도 생각해 보면 좋습니다
  - 추상 클래스를 사용하면 나중에 구상 상태 클래스 코드를 건드리지 않고도 추상 클래스에 메소드를 추가할 수 있으니까요
