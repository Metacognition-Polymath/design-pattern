# 12. 복합 패턴 - 패턴을 모아 패턴 만들기

## 패턴 섞어 쓰기

- 패턴을 잘 활용하는 방법 가운데 하나는 서로 다른 패턴을 섞어쓰는 것입니다
- 여러 패턴을 함께 사용해서 다양한 디자인 문제를 해결하는 방법을 복합 패턴이라고 부릅니다
- 실전에선 다양한 복합 패턴을 볼 수 있습니다
- 패턴을 몇 개를 결합한다고 해서 무조건 복합 패턴이 되는 것은 아닙니다
- 복합 패턴이라고 불리려면 여러가지 문제의 일반적인 해결법을 제시해야 합니다
- 여러 복합 패턴을 먼저 살펴본 다음, 복합 패턴의 왕이라고 할 수 있는 모델-뷰-컨트롤러(MVC) 패턴을 알아보겠습니다
- 하나의 디자인 문제를 해결하려고 여러 패턴을 함께 사용하는 경우가 종종 있습니다
- 복합 패턴이란 반복적으로 생길 수 있는 일반적인 문제를 해결하는 용도로 2개 이상의 패턴을 결합해서 사용하는 것을 뜻합니다

## 오리 시뮬레이션 게임에 다양한 패턴 적용하기

- 오리 시뮬레이션 게임을 처음부터 다시 만들며서 몇 가지 기능을 추가해 봅시다
- 이 과정에서 하나의 문제를 해결할 때 여러 패턴이 어떻게 공존하고 협력하는지 배울 수 있습니다

### 뇌단련

- 오리를 넣을 수 있는 곳이라면 거위도 넣을 수 있어야 합니다
- 사실 거위들도 소리를 내고 날기도 하고 헤엄도 치는데 시뮬레이션 게임에 넣지 못할 이유가 없죠
- 어떤 패턴을 활용하면 거위와 오리가 잘 어울려 놀 수 있을까요?

### 어댑터 추가하기

- 시뮬레이터는 Quackable 인터페이스를 원하지만, 거위는 quack()이 아닌 honk() 메소드가 들어있습니다

### 꽥꽥학

- 꽥꽥학자들은 오래전 부터 하나의 무리가 몇 번의 꽥꽥 소리를 내는지 연구하고 싶어했습니다
- 오리 클래스는 그대로 두면서 오리가 꽥꽥 소리를 낸 횟수를 세려면 어떤 패턴을 써야 할까요?

### 데코레이터로 감싸기

### 팩토리 메소드

- 오리 객체를 생성하는 작업을 한 군데에서 몰아서 해보자
- 오리를 생성하고 데코레이터로 감싸는 부분을 따로 빼내서 캡슐화해보자

### 추상 팩토리

- 조금 나아지긴 했지만 거위를 만들 때는 여전히 구상 클래스에 의존해서 직접 만들어야 합니다
- 거위를 생성하는 추상 팩토리를 추가해봅시다
- 책에서도 생략 됨

### 오리 무리를 관리하는 기능 - 컴포지트 패턴

- 오리 무리(정확하게 말하자면 Quackable 무리)를 만들어 봅시다
- 객체들로 구성된 컬렉션을 개별 객체와 같은 방식으로 다룰 수 있게 해주는 컴포지트 패턴

### 안전성 vs. 투명성

- 9장에서 컴포지트 패턴을 배웠을 때, 복합 객체(Menu)와 객체(MenuItem)에 똑같은 메소드가 있었습니다.
- 똑같은 메소드를 넣다보니 MenuItem 객체에 사용 되지 않는 add() 메소드도 똑같이 들어있었죠
- 이러면 잎과 복합 객체 사이의 차이점을 투명하게 만들 수 있다는 장점이 있습니다
- 클라이언트는 잎 객체를 다루고 있는지, 아니면 복합 객체를 다루고 있는지를 전혀 신경 쓸 필요가 없죠
- 그냥 무조건 같은 메소드를 호출하면 됩니다
- 여기에서는 복합 객체에서 자식을 관리하는 메소드를 복합 객체에만 넣었습니다
- add() 메소드는 Flock 클래스에만 있죠
- 어차피 오리 객체는 add()에게 아무 쓸모 없는 메소드니까요
- 심지어 아예 오리를 add() 메소드를 호출할 수 없고 오로지 Flock만 호출할 수 있죠
- 이런 디자인은(구성요소에서 어떤 의미도 갖지 못하는 메소드는 아예 호출할 수 없으므로) 더 안전하긴 합니다만,
- 대신 투명성은 떨어집니다
- 클라이언트가 어떤 객체에 Quackable을 추가하려면 그 객체가 Flock인지 아닌지를 확실하게 알고 있어야 하니까요
- 언제나 그렇듯이 객체지향 디자인을 할 때는 장점과 단점을 잘 따져봐야 합니다
- 복합 객체를 만들 때도 상황에 따라서 안정성과 투명성을 적당히 조절해야 합니다

### 14. 옵저버 패턴

- 꽥꽥학자가 개별 오리의 행동을 관찰하고 싶어합니다
- 옵저버 패턴을 적용해서 꽥꽥학자가 개별 오리의 행동을 관찰할 수 있게 해보겠습니다

- 2장과에서는 모든 클래스에 일일이 등록하고, 연락용 메소드를 구현했습니다
- 이번에는 등록 및 연락용 코드를 Observable 클래스에 캡슐화하고, 구성으로 QuackObservable에 포함시키겠습니다
  - 이러면 실제 코드는 한 군데에만 작성해 놓고, QuackObservable이 필요한 작업을 Observable 보조 클래스에 전부 위임하게 만들 수 있습니다

### QuackObservable을 확장한 Quackable에 맞는 Flock

- TODO: 해보기

## 무엇이든 물어보세요

- 여기에서 쓰인 게 복합 패턴인가요?

  - 복합 패턴이라고 할 순 없습니다.
  - 그냥 여러 패턴을 섞어서 썼을 뿐이죠.
  - 복합 패턴은 몇 개의 패턴을 복합적으로 사용해서 일반적인 문제를 해결할 수 있어야 합니다
  - 잠시 후에 모델-뷰-컨트롤러를 살펴볼텐데, 그 패턴은 다양한 디자인 문제를 해결하는 데 적용할 수 있으므로 복합 패턴입니다

- 디자인 패턴의 진정한 매력은 어떤 문제가 닥쳤을 때 패턴을 적용하다 보면 문제가 해결된다는 거죠?
  - 그렇진 않습니다.
  - 오리 시뮬레이션 게임을 만드는 데 여러 가지 패턴을 사용한 이유는 그냥 여러 패턴을 함께 사용할 수 있다는 사실을 보여주려고 했던 것뿐입니다
  - 실전에서 방금까지 했던 방식으로 디자인을 적용하는 일은 없을 것입니다
  - 오리 시뮬레이션 게임에 적용된 패턴 중에는 조금 과하다 싶은 것들도 있었죠
  - 상황에 따라 올바른 객체지향 디자인 원칙을 적용하는 것만으로도 문제가 해결되기도 합니다
  - 이와 관련된 내용은 13장에서 좀 더 알아보겠습니다
  - 일단 지금은 패턴은 반드시 상황에 맞게 써야 한다라는 사실만 기억하세요
  - 이 패턴을 써봐야지라고 생각하고 억지로 패턴을 적용해서는 안 됩니다
  - 방금까지 살펴본 디자인은 상당히 부자연스럽고, 억지스러운 부분이 많다는 사실을 명심합시다
  - 하지만 재밌었지 않았나요? 한 문제를 해결하는 데 여러 패턴을 적용할 수 있다는 사실을 배울 수 있었잖아요?

## 바뀐 내용 되돌아 보기

- 처음에 수 많은 Quackable들이 있었습니다
- 갑자기 거위가 나타나서 자기도 Quackable이 되고 싶다고 했죠
  - 그래서 어댑터 패턴을 써서 Quackable에 맞게 만들어 줬습니다
- 꽥꽥학자들이 등장해서 꽥꽥 소리가 난 횟수를 세고 싶다고 했습니다
  - 그래서 데코레이터 패턴을 적용해서, QuackCounter 데코레이터를 추가하고 quack()이 호출된 회수를 셀 수 있게 만들었습니다
  - quack() 메소드 호출 자체는 그 데코레이터로 싸여 있는 Quackable 객체가 처리합니다
- 하지만 꽥꽥학자들이 QuackCounter로 장식되지 않은 Quackable 객체가 있을까 봐 걱정된다고 하더군요
  - 그래서 추상 팩토리 패턴을 써서 팩토리가 객체를 만들도록 했습니다
  - 오리객체를 만들 때는 항상 팩토리에 요청을 하게 되니까, 팩토리가 데코레이터로 싸여 있는 오리를 리턴하게 해서 문제를 해결했습니다
  - 그리고 데코레이터로 장식되지 않은 오리를 원한다면 다른 팩토리를 쓰면 된다는 것도 기억해 둡시다
- 모든 오리와 거위, Quackable 객체를 관리하기가 힘들어지기 시작했습니다
  - 그래서 컴포지트 패턴을 써서 오리들을 모아서 오리 무리 단위로 관리하기로 했습니다
  - 이 패턴을 사용하면 꽥꽥학자들은 수 많은 오리를 종별로 나눠서 관리할 수도 있습니다
  - 그 패턴을 구현하는 과정에서 반복자를 사용해서 반복자 패턴까지 적용했죠
- 꽥꽥학자들은 Quackable에서 소리르 냈을 때 바로 연락받고 싶어 했습니다
  - 그래서 옵저버 패턴을 써서 Quackologist를 Quackable의 옵저버로 등록했죠
  - 이제 Quackable에서 소리를 낼 때 마다 연락을 받을 수 있습니다
  - 여기에서도 반복자 패턴이 적용되었습니다
  - 옵저버 패턴은 복합 객체 내에서도 전혀 문제 없이 잘 작동했습니다
