# 12. 복합 패턴 - 패턴을 모아 패턴 만들기

## 패턴 섞어 쓰기

- 패턴을 잘 활용하는 방법 가운데 하나는 서로 다른 패턴을 섞어쓰는 것입니다
- 여러 패턴을 함께 사용해서 다양한 디자인 문제를 해결하는 방법을 복합 패턴이라고 부릅니다
- 실전에선 다양한 복합 패턴을 볼 수 있습니다
- 패턴을 몇 개를 결합한다고 해서 무조건 복합 패턴이 되는 것은 아닙니다
- 복합 패턴이라고 불리려면 여러가지 문제의 일반적인 해결법을 제시해야 합니다
- 여러 복합 패턴을 먼저 살펴본 다음, 복합 패턴의 왕이라고 할 수 있는 모델-뷰-컨트롤러(MVC) 패턴을 알아보겠습니다
- 하나의 디자인 문제를 해결하려고 여러 패턴을 함께 사용하는 경우가 종종 있습니다
- 복합 패턴이란 반복적으로 생길 수 있는 일반적인 문제를 해결하는 용도로 2개 이상의 패턴을 결합해서 사용하는 것을 뜻합니다

## 오리 시뮬레이션 게임에 다양한 패턴 적용하기

- 오리 시뮬레이션 게임을 처음부터 다시 만들며서 몇 가지 기능을 추가해 봅시다
- 이 과정에서 하나의 문제를 해결할 때 여러 패턴이 어떻게 공존하고 협력하는지 배울 수 있습니다

### 뇌단련

- 오리를 넣을 수 있는 곳이라면 거위도 넣을 수 있어야 합니다
- 사실 거위들도 소리를 내고 날기도 하고 헤엄도 치는데 시뮬레이션 게임에 넣지 못할 이유가 없죠
- 어떤 패턴을 활용하면 거위와 오리가 잘 어울려 놀 수 있을까요?

### 어댑터 추가하기

- 시뮬레이터는 Quackable 인터페이스를 원하지만, 거위는 quack()이 아닌 honk() 메소드가 들어있습니다

### 꽥꽥학

- 꽥꽥학자들은 오래전 부터 하나의 무리가 몇 번의 꽥꽥 소리를 내는지 연구하고 싶어했습니다
- 오리 클래스는 그대로 두면서 오리가 꽥꽥 소리를 낸 횟수를 세려면 어떤 패턴을 써야 할까요?

### 데코레이터로 감싸기

### 팩토리 메소드

- 오리 객체를 생성하는 작업을 한 군데에서 몰아서 해보자
- 오리를 생성하고 데코레이터로 감싸는 부분을 따로 빼내서 캡슐화해보자

### 추상 팩토리

- 조금 나아지긴 했지만 거위를 만들 때는 여전히 구상 클래스에 의존해서 직접 만들어야 합니다
- 거위를 생성하는 추상 팩토리를 추가해봅시다
- 책에서도 생략 됨

### 오리 무리를 관리하는 기능 - 컴포지트 패턴

- 오리 무리(정확하게 말하자면 Quackable 무리)를 만들어 봅시다
- 객체들로 구성된 컬렉션을 개별 객체와 같은 방식으로 다룰 수 있게 해주는 컴포지트 패턴

### 안전성 vs. 투명성

- 9장에서 컴포지트 패턴을 배웠을 때, 복합 객체(Menu)와 객체(MenuItem)에 똑같은 메소드가 있었습니다.
- 똑같은 메소드를 넣다보니 MenuItem 객체에 사용 되지 않는 add() 메소드도 똑같이 들어있었죠
- 이러면 잎과 복합 객체 사이의 차이점을 투명하게 만들 수 있다는 장점이 있습니다
- 클라이언트는 잎 객체를 다루고 있는지, 아니면 복합 객체를 다루고 있는지를 전혀 신경 쓸 필요가 없죠
- 그냥 무조건 같은 메소드를 호출하면 됩니다
- 여기에서는 복합 객체에서 자식을 관리하는 메소드를 복합 객체에만 넣었습니다
- add() 메소드는 Flock 클래스에만 있죠
- 어차피 오리 객체는 add()에게 아무 쓸모 없는 메소드니까요
- 심지어 아예 오리를 add() 메소드를 호출할 수 없고 오로지 Flock만 호출할 수 있죠
- 이런 디자인은(구성요소에서 어떤 의미도 갖지 못하는 메소드는 아예 호출할 수 없으므로) 더 안전하긴 합니다만,
- 대신 투명성은 떨어집니다
- 클라이언트가 어떤 객체에 Quackable을 추가하려면 그 객체가 Flock인지 아닌지를 확실하게 알고 있어야 하니까요
- 언제나 그렇듯이 객체지향 디자인을 할 때는 장점과 단점을 잘 따져봐야 합니다
- 복합 객체를 만들 때도 상황에 따라서 안정성과 투명성을 적당히 조절해야 합니다

### 14. 옵저버 패턴

- 꽥꽥학자가 개별 오리의 행동을 관찰하고 싶어합니다
- 옵저버 패턴을 적용해서 꽥꽥학자가 개별 오리의 행동을 관찰할 수 있게 해보겠습니다

- 2장과에서는 모든 클래스에 일일이 등록하고, 연락용 메소드를 구현했습니다
- 이번에는 등록 및 연락용 코드를 Observable 클래스에 캡슐화하고, 구성으로 QuackObservable에 포함시키겠습니다
  - 이러면 실제 코드는 한 군데에만 작성해 놓고, QuackObservable이 필요한 작업을 Observable 보조 클래스에 전부 위임하게 만들 수 있습니다

### QuackObservable을 확장한 Quackable에 맞는 Flock

- TODO: 해보기

## 무엇이든 물어보세요

- 여기에서 쓰인 게 복합 패턴인가요?

  - 복합 패턴이라고 할 순 없습니다.
  - 그냥 여러 패턴을 섞어서 썼을 뿐이죠.
  - 복합 패턴은 몇 개의 패턴을 복합적으로 사용해서 일반적인 문제를 해결할 수 있어야 합니다
  - 잠시 후에 모델-뷰-컨트롤러를 살펴볼텐데, 그 패턴은 다양한 디자인 문제를 해결하는 데 적용할 수 있으므로 복합 패턴입니다

- 디자인 패턴의 진정한 매력은 어떤 문제가 닥쳤을 때 패턴을 적용하다 보면 문제가 해결된다는 거죠?
  - 그렇진 않습니다.
  - 오리 시뮬레이션 게임을 만드는 데 여러 가지 패턴을 사용한 이유는 그냥 여러 패턴을 함께 사용할 수 있다는 사실을 보여주려고 했던 것뿐입니다
  - 실전에서 방금까지 했던 방식으로 디자인을 적용하는 일은 없을 것입니다
  - 오리 시뮬레이션 게임에 적용된 패턴 중에는 조금 과하다 싶은 것들도 있었죠
  - 상황에 따라 올바른 객체지향 디자인 원칙을 적용하는 것만으로도 문제가 해결되기도 합니다
  - 이와 관련된 내용은 13장에서 좀 더 알아보겠습니다
  - 일단 지금은 패턴은 반드시 상황에 맞게 써야 한다라는 사실만 기억하세요
  - 이 패턴을 써봐야지라고 생각하고 억지로 패턴을 적용해서는 안 됩니다
  - 방금까지 살펴본 디자인은 상당히 부자연스럽고, 억지스러운 부분이 많다는 사실을 명심합시다
  - 하지만 재밌었지 않았나요? 한 문제를 해결하는 데 여러 패턴을 적용할 수 있다는 사실을 배울 수 있었잖아요?

## 바뀐 내용 되돌아 보기

- 처음에 수 많은 Quackable들이 있었습니다
- 갑자기 거위가 나타나서 자기도 Quackable이 되고 싶다고 했죠
  - 그래서 어댑터 패턴을 써서 Quackable에 맞게 만들어 줬습니다
- 꽥꽥학자들이 등장해서 꽥꽥 소리가 난 횟수를 세고 싶다고 했습니다
  - 그래서 데코레이터 패턴을 적용해서, QuackCounter 데코레이터를 추가하고 quack()이 호출된 회수를 셀 수 있게 만들었습니다
  - quack() 메소드 호출 자체는 그 데코레이터로 싸여 있는 Quackable 객체가 처리합니다
- 하지만 꽥꽥학자들이 QuackCounter로 장식되지 않은 Quackable 객체가 있을까 봐 걱정된다고 하더군요
  - 그래서 추상 팩토리 패턴을 써서 팩토리가 객체를 만들도록 했습니다
  - 오리객체를 만들 때는 항상 팩토리에 요청을 하게 되니까, 팩토리가 데코레이터로 싸여 있는 오리를 리턴하게 해서 문제를 해결했습니다
  - 그리고 데코레이터로 장식되지 않은 오리를 원한다면 다른 팩토리를 쓰면 된다는 것도 기억해 둡시다
- 모든 오리와 거위, Quackable 객체를 관리하기가 힘들어지기 시작했습니다
  - 그래서 컴포지트 패턴을 써서 오리들을 모아서 오리 무리 단위로 관리하기로 했습니다
  - 이 패턴을 사용하면 꽥꽥학자들은 수 많은 오리를 종별로 나눠서 관리할 수도 있습니다
  - 그 패턴을 구현하는 과정에서 반복자를 사용해서 반복자 패턴까지 적용했죠
- 꽥꽥학자들은 Quackable에서 소리르 냈을 때 바로 연락받고 싶어 했습니다
  - 그래서 옵저버 패턴을 써서 Quackologist를 Quackable의 옵저버로 등록했죠
  - 이제 Quackable에서 소리를 낼 때 마다 연락을 받을 수 있습니다
  - 여기에서도 반복자 패턴이 적용되었습니다
  - 옵저버 패턴은 복합 객체 내에서도 전혀 문제 없이 잘 작동했습니다

## 복합 패턴의 왕 알현하기

- MVC는 코드를 기능에 따라 나눠주는 패러다임
- 재사용을 하려면 깔끔하게 나눠 줘야 한다
- 한 쪽에는 모델이, 다른 쪽에는 뷰, 그 사이에는 컨트롤러가 있다
  - 모델 - 컨트롤러 - 뷰
- 모델 객체 : 애플리케이션 존재의 의미

  - 데이터, 놀리 같은 게 전부 들어있는 객체
  - 그 클래스는 애플리케이션의 문제를 해결하는 클래스
  - 어떤 뷰에서도 재사용할 수 있다
  - 뷰가 바뀌어도 모델 객체는 그대로 남는다

- 뷰 객체 : 표시하고 편집하는 컨트롤에는 훌륭한 컨트롤이 가득하다

  - 사용자가 조작할 수 있고, 거의 무엇이든 담을 수 있다
  - 하지만 뷰는 모델을 모른다
  - 그 문자열은 전화번호일 수도 있고 아리스토텔레스의 작품일 수도 있다
  - 연결은 느슨하게 재사용을 최고로 끌어올리자

- 데이터는 모델과 뷰 사이에서 움직인다

  - 컨트롤러는 둘 사이의 중계자
  - 각 계층의 상태가 바뀌면 그 둘의 데이터를 동기화한다
  - 바뀐 값을 부지런히 날라다 준다

### 모델-뷰-컨트롤러의 핵심은 디자인 패턴입니다

- MVC는 여러 패턴을 합쳐놓았다는 사실을 먼저 이해해야 합니다
- 패턴을 바라보는 눈으로 MVC를 공부하다 보면 어느 순간 깨달음을 얻을 겁니다

## 모델-뷰-컨트롤러 알아보기

- iTunes 같은 음악 소프트웨어를 사용하고 있다고 가정해 봅시다.
- 소프트웨어에서 제공하는 인터페이스를 사용해서

  - 새로운 곡을 추가하거나
  - 재생목록을 관리하거나
  - 트랙이름을 바꿀 수 있습니다

- 그 플레이어는 모든 곡의 정보, 그 곡과 관련된 모든 이름과 데이터를 담고 있는 조그만 데이터베이스를 관리합니다
- 곡을 재생하고, 재생하는 동안에 현재 곡 제목, 재생시간과 같은 다양한 정보를 사용자 인터페이스 상에서 갱신해 주는 일도 플레이어에서 처리해주죠
- 플레이어 뒤에서 일을 해 주고 있는 게 모델-뷰-컨트롤러 입니다

- e.g.
  - `사용자`가 인터페이스를 건드리면 그 행동이 `컨트롤러`에게 전달됩니다
    - 새로운 노래 재생
  - `컨트롤러`에서 `모델`을 조작
    - 컨트롤러에서 Player 모델에게 음악 재생을 요청합니다
  - 모델
    - MP3 파일을 관리하고 재생하는 데 필요한 모든 상태, 데이터, 애플리케이션 로직 등은 모델에 들어있습니다
  - 상태 변화 통지
    - 모델은 뷰에게 상태가 변경되었음을 알립니다
  - 뷰 디스플레이 갱신
    - 디스플레이가 생신되는 것을 볼 수 있고, 음악이 재생되는 것을 들을 수 있습니다

## 모델-뷰-컨트롤러 조금 더 알아보기

- 모델, 뷰, 컨트롤러의 관계를 살펴본 다음 디자인 패턴의 관점으로 다시 한번 바라보겠습니다

![](./images/MVC%ED%8C%A8%ED%84%B4.jpeg)

### 뷰

- 모델을 표현하는 방법을 제공합니다
- 일반적으로 화면에 표시할 때 필요한 상태와 데이터는 모델에서 직접 가져옵니다

### 컨트롤러

- 사용자로부터 입력을 받으며 입력받은 내용이 모델에게 어떤 의미가 있는지 파악합니다

### 모델

- 모델에는 모든 데이터, 상태와 애플리케이션 로직이 들어있습니다
- 뷰와 컨트롤러에서 모델의 상태를 조작하거나 가져올 때 필요한 인터페이스를 제공하고,
  - 모델이 자신의 상태 변화를 옵저버들에게 연락해 주긴 하지만,
  - 기본적으로 모델은 뷰와 컨트롤러에 별 관심이 없습니다

### MVC 동작 방식

1. `사용자`는 `뷰`에만 접촉할 수 있습니다

   - 뷰는 모델을 보여주는 창이라고 할 수 있씁니다
   - 자용자가 뷰에서 (재생 버튼을 누른다든가 하는 식으로) 뭔가를 하면 뷰는 무슨 일이 일어났는지 `컨트롤러에게 알려 줍니다`
   - 그러면 컨트롤러가 상황에 맞게 작업을 처리합니다

2. `컨트롤러`가 `모델`에게 `상태를 변경`하라고 요청합니다

   - 컨트롤러는 사용자의 행동을 받아서 해석합니다
   - 사용자가 버튼을 클릭하면 컨트롤러는 그것이 무엇을 의미하는지 해석하고, 모델을 어떤 식으로 조작해야 하는지 결정합니다

3. `컨트롤러`가 `뷰`를 변경해 달라고 요청할 수도 있습니다

   - 컨트롤러는 뷰로부터 어떤 행동을 받았을 때, 그 행동의 결과로 뷰에게 뭔가를 바꿔 달라고 할 수도 있습니다
   - 예를 들어, 컨트롤러는 인터페이스에 있는 어떤 버튼이나 메뉴를 활성화하거나 비활성화할 수 있습니다

4. 상태가 변경되면 `모델`이 `뷰`에게 그 사실을 알립니다

   - 사용자가 한 행동(버튼 클릭 등)이나 다른 내부적인 변화(재생목록에서 다음 곡이 재생되는 것 등) 등으로 모델에서 뭔가가 바뀌면 모델은 뷰에게 상태가 변경되었다고 알립니다

5. `뷰`가 `모델`에게 `상태를 요청`합니다
   - 뷰는 화면에 표시할 `상태를 모델로부터 직접 가져옵니다`
   - 예를 들어, 모델이 뷰에게 새로운 곡이 재생되었다고 알려 주면 뷰는 모델에게 곡 제목을 요청하고,
     - 그것을 받아서 화면에 표시합니다
     - 컨트롤러가 뷰에게 뭔가를 바꾸라고 요청을 했을 때도 뷰는 모델에게 상태를 알려 달라고 요청할 수도 있겠죠

## 무엇이든 물어보세요

- Q1) 컨트롤러가 모델의 옵저버가 되는 경우는 없나요?
- A1) 옵저버가 되는 경우도 있습니다

  - 디자인에 따라 컨트롤러도 모델에 옵저버로 등록하고, 상태가 변경될 때 모델로부터 연락을 받을 수 있습니다
  - 모델에 있는 뭔가에 의해서 사용자 인터페이스 컨트롤이 직접 변경된다면 이렇게 해야겠죠
  - 예를들어,
    - 모델이 있는 어떤 상태에 따라서 인터페이스 항목이 활성화되거나 비활성화되는 경우를 생각할 수 있습니다
    - 그런 경우에는 컨트롤러가 뷰에게 상황에 맞게 화면을 갱신해 달라고 요청합니다

- Q2) 그러면 컨트롤러는 뷰로부터 사용자 입력을 받아 오고 모델에게 보내는 일만 하는 거죠?
  - 그 일밖에 하지 않는다면 왜 굳이 컨트롤러를 쓰는 거죠?
  - 뷰에 그 코드를 넣어도 되잖아요
  - 어차피 컨트롤러가 하는 일이라고는 모델에 있는 메소드를 호출하는 것뿐이잖아요
- A2) 컨트롤러가 그냥 '모델한테 전달하는' 일만 하는 것은 아닙니다
  - 컨트롤러는 사용자가 입력한 내용을 해석해서 모델을 조작하는 임무를 맡고 있습니다
  - 하지만 "왜 뷰에 그런 기능을 바로 넣지 않았을까?"라는 질문을 따로 대답을 해야 할 것 같군요
  - 물론 뷰에 그런 기능을 직접 넣어도 되지만, 2가지 이유로 그렇게 하지 않는 것이 좋습니다
    - 우선 2가지 역할을 하게 되면 뷰 코드가 복잡해진다는 문제가 있죠
      - 사용자 인터페이스도 관리해야 하고, 모델을 제어하는 로직도 처리해야 하니까요
    - 다른 이유로는 뷰를 모델에 너무 밀접하게 연관시켜야 한다는 문제가 있습니다
      - 이러면 뷰를 다른 모델과 연결해서 재사용하기가 아주 힘들어집니다
      - 컨트롤러는 제어로직을 뷰로부터 분리해서 뷰와 모델의 결합을 끊어 주는 역할을 합니다
      - 뷰와 컨트롤러를 느슨하게 결합하면 더 유연하고 확장하기 좋은 디자인을 만들 수 있죠
      - 결국 나중에 뭔가를 바꿔야 할 때도 더 쉽게 바꿀 수 있고요
